#include "stdafx.h"
#include "ByteCrypt.h"
#include "ByteCryptDef.h"
#include "ByteCryptDefVer1.h"
#include "ByteCryptDefVer2.h"
#include <strstream>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

namespace BYTECRYPT
{
	UCHAR ARRAY_USE[EMBYTECRYPT_SIZE][256];
	BOOL bVALIDARRAY = FALSE;

	void InitArray()
	{
		if ( bVALIDARRAY )	return;

		//copy arrays
		for ( int i=0; i<256; ++i )
		{
			ARRAY_USE[EMBYTECRYPT_NONE][i]			= ARRAY_NONE[i];
			ARRAY_USE[EMBYTECRYPT_OLD][i]			= ARRAY_OLD[i];
			ARRAY_USE[EMBYTECRYPT_RAN2][i]			= ARRAY_RAN2[i];

			ARRAY_USE[EMBYTECRYPT_LEVEL][i]			= ARRAY_LEVEL_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_WLD][i]			= ARRAY_WLD_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_CROWSALE][i]		= ARRAY_CROWSALE_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_NPCTALK][i]		= ARRAY_NPCTALK_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_QUEST][i]			= ARRAY_QUEST_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_ITEM][i]			= ARRAY_ITEM_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_CROW][i]			= ARRAY_CROW_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_CLASSCONST][i]	= ARRAY_CLASSCONST_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_PETCHARSET][i]	= ARRAY_PETCHARSET_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_SKILL][i]			= ARRAY_SKILL_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_CHARSET][i]		= ARRAY_CHARSET_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_CONTAINER][i]		= ARRAY_CONTAINER_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_PIECE][i]			= ARRAY_PIECE_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_ITEMIX][i]		= ARRAY_ITEMIX_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_CFG][i]			= ARRAY_CFG_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_EGP][i]			= ARRAY_EGP_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_BIN][i]			= ARRAY_BIN_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_TAXISTATION][i]	= ARRAY_TAXISTATION_VAR1[i];
			ARRAY_USE[EMBYTECRYPT_MAPSLIST][i]		= ARRAY_MAPSLIST_VAR1[i];

			ARRAY_USE[EMBYTECRYPT_LEVEL2][i]		= ARRAY_LEVEL_VER2[i];
			ARRAY_USE[EMBYTECRYPT_WLD2][i]			= ARRAY_WLD_VER2[i];
			ARRAY_USE[EMBYTECRYPT_CROWSALE2][i]		= ARRAY_CROWSALE_VER2[i];
			ARRAY_USE[EMBYTECRYPT_NPCTALK2][i]		= ARRAY_NPCTALK_VER2[i];
			ARRAY_USE[EMBYTECRYPT_QUEST2][i]		= ARRAY_QUEST_VER2[i];
			ARRAY_USE[EMBYTECRYPT_ITEM2][i]			= ARRAY_ITEM_VER2[i];
			ARRAY_USE[EMBYTECRYPT_CROW2][i]			= ARRAY_CROW_VER2[i];
			ARRAY_USE[EMBYTECRYPT_CLASSCONST2][i]	= ARRAY_CLASSCONST_VER2[i];
			ARRAY_USE[EMBYTECRYPT_PETCHARSET2][i]	= ARRAY_PETCHARSET_VER2[i];
			ARRAY_USE[EMBYTECRYPT_SKILL2][i]		= ARRAY_SKILL_VER2[i];
			ARRAY_USE[EMBYTECRYPT_CHARSET2][i]		= ARRAY_CHARSET_VER2[i];
			ARRAY_USE[EMBYTECRYPT_CONTAINER2][i]	= ARRAY_CONTAINER_VER2[i];
			ARRAY_USE[EMBYTECRYPT_PIECE2][i]		= ARRAY_PIECE_VER2[i];
			ARRAY_USE[EMBYTECRYPT_ITEMIX2][i]		= ARRAY_ITEMIX_VER2[i];
			ARRAY_USE[EMBYTECRYPT_CFG2][i]			= ARRAY_CFG_VER2[i];
			ARRAY_USE[EMBYTECRYPT_EGP2][i]			= ARRAY_EGP_VER2[i];
			ARRAY_USE[EMBYTECRYPT_BIN2][i]			= ARRAY_BIN_VER2[i];
			ARRAY_USE[EMBYTECRYPT_TAXISTATION2][i]	= ARRAY_TAXISTATION_VER2[i];
			ARRAY_USE[EMBYTECRYPT_MAPSLIST2][i]		= ARRAY_MAPSLIST_VER2[i];
			ARRAY_USE[EMBYTECRYPT_ACTIVITY][i]		= ARRAY_ACTIVITY[i];
		}

		//check if there are duplicates
		for ( int nArray=0; nArray<EMBYTECRYPT_SIZE; ++nArray )
		{
			for ( int i=0; i<256; ++i )
			{
				for ( int j=0; j<256; ++j )
				{
					if ( i==j )	continue;

					if ( DWORD( ARRAY_USE[nArray][i]) == DWORD( ARRAY_USE[nArray][j]) )
						CDebugSet::MsgBox( "%s Duplicate In:%d~%d Value:%x", strCrypt[nArray].c_str(), i, j, ARRAY_USE[nArray][i] );
				}
			}
		}

		bVALIDARRAY = TRUE;
	};
	
	void byte_encode ( BYTE* pbuffer, DWORD dwSize, EMBYTECRYPT emCRYPT )
	{
		if ( !pbuffer )
		{
			CDebugSet::MsgBox( "byte_encode Invalid buffer" );
		}

		if ( emCRYPT == EMBYTECRYPT_NONE )	return;
		if ( emCRYPT >= EMBYTECRYPT_SIZE )	return;

		InitArray();

		for ( DWORD i=0; i<dwSize; ++i )		
		{
			pbuffer[i] = ARRAY_USE[emCRYPT][static_cast<DWORD>(pbuffer[i])];
		}
	}

	void byte_decode ( BYTE* pbuffer, DWORD dwSize, EMBYTECRYPT emCRYPT )
	{
		if ( !pbuffer )
		{
			CDebugSet::MsgBox( "byte_decode Invalid buffer" );
		}

		if ( emCRYPT == EMBYTECRYPT_NONE )	return;
		if ( emCRYPT >= EMBYTECRYPT_SIZE )	return;

		InitArray();

		UCHAR DEARRAY[256];
		for ( DWORD i=0; i<256; ++i )		
		{
			DEARRAY[static_cast<DWORD>(ARRAY_USE[emCRYPT][i])] = UCHAR(i);
		}

		for ( DWORD i=0; i<dwSize; ++i )		
		{
			pbuffer[i] = DEARRAY[static_cast<DWORD>(pbuffer[i])];
		}
	}

	std::string strCrypt[EMBYTECRYPT_SIZE] =
	{
		"EMBYTECRYPT_NONE",
		"EMBYTECRYPT_OLD",
		"EMBYTECRYPT_RAN2",
		"EMBYTECRYPT_LEVEL",
		"EMBYTECRYPT_WLD",
		"EMBYTECRYPT_CROWSALE",
		"EMBYTECRYPT_NPCTALK",
		"EMBYTECRYPT_QUEST",
		"EMBYTECRYPT_ITEM",
		"EMBYTECRYPT_CROW",
		"EMBYTECRYPT_CLASSCONST",
		"EMBYTECRYPT_PETCHARSET",
		"EMBYTECRYPT_SKILL",
		"EMBYTECRYPT_CHARSET",
		"EMBYTECRYPT_CONTAINER",
		"EMBYTECRYPT_PIECE",
		"EMBYTECRYPT_ITEMMIX",
		"EMBYTECRYPT_CFG",
		"EMBYTECRYPT_EGP",
		"EMBYTECRYPT_BIN",
		"EMBYTECRYPT_TAXISTATION",
		"EMBYTECRYPT_MAPSLIST",
		"EMBYTECRYPT_LEVEL2",
		"EMBYTECRYPT_WLD2",
		"EMBYTECRYPT_CROWSALE2",
		"EMBYTECRYPT_NPCTALK2",
		"EMBYTECRYPT_QUEST2",
		"EMBYTECRYPT_ITEM2",
		"EMBYTECRYPT_CROW2",
		"EMBYTECRYPT_CLASSCONST2",
		"EMBYTECRYPT_PETCHARSET2",
		"EMBYTECRYPT_SKILL2",
		"EMBYTECRYPT_CHARSET2",
		"EMBYTECRYPT_CONTAINER2", 
		"EMBYTECRYPT_PIECE2",
		"EMBYTECRYPT_ITEMIX2",
		"EMBYTECRYPT_CFG2",
		"EMBYTECRYPT_EGP2",
		"EMBYTECRYPT_BIN2",
		"EMBYTECRYPT_TAXISTATION2",
		"EMBYTECRYPT_MAPSLIST2",
		"EMBYTECRYPT_ACTIVITY",
	};
}